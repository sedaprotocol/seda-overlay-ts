import { fromBase64, fromUtf8 } from "@cosmjs/encoding";
import { decodeTxRaw } from "@cosmjs/proto-signing";
import type { Block, BlockResultsResponse } from "@cosmjs/tendermint-rpc/build/tendermint37";
import { logger } from "@sedaprotocol/overlay-ts-logger";
import { Maybe, Result } from "true-myth";
import type { BlockEvent, ParsedMessage, ParsedTransaction, SedaMessageContext } from "./block-monitor";

export class TransactionParser {
  parseBlock(block: Block, blockResults: BlockResultsResponse): ParsedTransaction[] {
    const parsedTransactions: ParsedTransaction[] = [];

    // Check if block has transactions
    const txs = (block as any).data?.txs || [];
    logger.debug(`TransactionParser: Block has ${txs.length} raw transactions`);
    
    if (txs.length === 0) {
      logger.debug("TransactionParser: No transactions in block");
      return parsedTransactions;
    }

    // Log transaction structure
    logger.debug(`TransactionParser: Raw transaction types: ${txs.map((tx: any, i: number) => `${i}:${typeof tx}`).join(', ')}`);
    
    // Log block results structure
    const txResults = (blockResults as any).results || (blockResults as any).txs_results || [];
    logger.debug(`TransactionParser: Block results has ${txResults.length} transaction results`);

    for (let i = 0; i < txs.length; i++) {
      try {
        logger.debug(`TransactionParser: Processing transaction ${i}/${txs.length}`);
        
        const rawTx = txs[i];
        logger.debug(`TransactionParser: Raw tx ${i} - type: ${typeof rawTx}, length: ${rawTx?.length || 'unknown'}`);
        
        if (typeof rawTx !== 'string') {
          logger.warn(`TransactionParser: Transaction ${i} is not a string, skipping`);
          continue;
        }
        
        const txBytes = fromBase64(rawTx);
        logger.debug(`TransactionParser: Decoded tx ${i} to ${txBytes.length} bytes`);
        
        const txRaw = decodeTxRaw(txBytes);
        logger.debug(`TransactionParser: Parsed tx ${i} - body messages: ${txRaw.body.messages.length}`);
        
        // Get transaction result from block results  
        const txResult = txResults[i];
        const success = txResult?.code === 0;
        logger.debug(`TransactionParser: Tx ${i} result - success: ${success}, code: ${txResult?.code}`);
        
        // Parse messages from the transaction
        const messages = this.parseMessages(txRaw.body.messages);
        logger.debug(`TransactionParser: Tx ${i} parsed ${messages.length} messages`);
        
        const parsedTx: ParsedTransaction = {
          hash: this.getTxHash(rawTx),
          success,
          messages
        };

        parsedTransactions.push(parsedTx);

        if (success && this.hasSedaMessages(messages)) {
          logger.info(`TransactionParser: Found SEDA transaction at index ${i}`);
        }
      } catch (error) {
        logger.warn(`TransactionParser: Failed to parse transaction ${i}: ${error}`);
      }
    }

    logger.debug(`TransactionParser: Parsed ${parsedTransactions.length} transactions from ${txs.length} raw transactions`);
    return parsedTransactions;
  }

  parseMessages(messages: any[]): ParsedMessage[] {
    const parsedMessages: ParsedMessage[] = [];

    for (const message of messages) {
      try {
        const parsedMessage: ParsedMessage = {
          typeUrl: message.typeUrl || '',
          value: message.value,
          sedaContext: this.extractSedaContext(message)
        };

        parsedMessages.push(parsedMessage);
      } catch (error) {
        logger.warn("Failed to parse message");
      }
    }

    return parsedMessages;
  }

  private extractSedaContext(message: any): SedaMessageContext | undefined {
    if (!message.typeUrl) return undefined;

    // Check for SEDA-specific message types based on typeUrl
    // All data extraction comes from message.value (transaction arguments), NOT events
    if (message.typeUrl.includes('post_data_request')) {
      return {
        type: 'post_data_request'
        // DR ID will be generated by DataRequestIdGenerator from message.value
      };
    }

    if (message.typeUrl.includes('commit_data_result')) {
      return {
        type: 'commit_data_result',
        // Extract from transaction arguments (message.value), NOT events
        commitmentHash: message.value?.commitment,
        publicKey: message.value?.public_key
      };
    }

    if (message.typeUrl.includes('reveal_data_result')) {
      return {
        type: 'reveal_data_result',
        // Extract from transaction arguments (message.value), NOT events  
        publicKey: message.value?.public_key
      };
    }

    return undefined;
  }

  private hasSedaMessages(messages: ParsedMessage[]): boolean {
    return messages.some(msg => msg.sedaContext !== undefined);
  }

  private getTxHash(txBase64: string): string {
    // For now, use a simple hash of the base64 string
    // In a real implementation, this would be the actual transaction hash
    const hash = Array.from(fromBase64(txBase64))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('')
      .substring(0, 64);
    
    return hash;
  }

  extractDataRequestId(message: ParsedMessage): string | null {
    // For post_data_request messages, DR ID needs to be generated from arguments
    if (message.sedaContext?.type === 'post_data_request') {
      return null; // Will be generated by DataRequestIdGenerator from message.value
    }

    // For commit/reveal messages, extract DR ID from message arguments
    if (message.sedaContext?.type === 'commit_data_result' || 
        message.sedaContext?.type === 'reveal_data_result') {
      // Extract from message.value (transaction arguments), NOT events
      return message.value?.data_request_id || null;
    }

    return null;
  }

  extractDataRequestAttributes(message: ParsedMessage): any | null {
    if (!message.sedaContext) return null;

    // Extract all DR attributes from transaction arguments (message.value)
    switch (message.sedaContext.type) {
      case 'post_data_request':
        // Extract all arguments needed for DR ID generation and processing
        return {
          version: message.value?.version,
          exec_program_id: message.value?.exec_program_id,
          exec_inputs: message.value?.exec_inputs,
          exec_gas_limit: message.value?.exec_gas_limit,
          tally_program_id: message.value?.tally_program_id,
          tally_inputs: message.value?.tally_inputs,
          tally_gas_limit: message.value?.tally_gas_limit,
          replication_factor: message.value?.replication_factor,
          consensus_filter: message.value?.consensus_filter,
          gas_price: message.value?.gas_price,
          memo: message.value?.memo
        };

      case 'commit_data_result':
        // Extract commit-specific arguments
        return {
          data_request_id: message.value?.data_request_id,
          commitment: message.value?.commitment,
          public_key: message.value?.public_key
        };

      case 'reveal_data_result':
        // Extract reveal-specific arguments
        return {
          data_request_id: message.value?.data_request_id,
          public_key: message.value?.public_key,
          reveal_data: message.value?.reveal_data
        };

      default:
        return null;
    }
  }

  isSuccessfulTransaction(txResult: any): boolean {
    return txResult?.code === 0;
  }

  // Parse transactions and populate BlockEvent
  enhanceBlockEvent(blockEvent: BlockEvent): BlockEvent {
    const transactions = this.parseBlock(blockEvent.block, blockEvent.blockResults);
    
    return {
      ...blockEvent,
      transactions
    };
  }
} 