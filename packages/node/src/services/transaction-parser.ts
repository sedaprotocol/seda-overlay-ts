import { fromBase64, fromUtf8 } from "@cosmjs/encoding";
import { decodeTxRaw } from "@cosmjs/proto-signing";
import type { Block, BlockResultsResponse } from "@cosmjs/tendermint-rpc/build/tendermint37";
import type { Event } from "@cosmjs/tendermint-rpc/build/tendermint37/responses";
import { logger } from "@sedaprotocol/overlay-ts-logger";
import { Maybe, Result } from "true-myth";
import type { BlockEvent, ParsedMessage, ParsedTransaction, SedaMessageContext } from "./block-monitor";

export class TransactionParser {
  parseBlock(block: Block, blockResults: BlockResultsResponse): ParsedTransaction[] {
    const parsedTransactions: ParsedTransaction[] = [];

    // Check if block has transactions
    const txs = (block as any).data?.txs || [];
    if (txs.length === 0) {
      return parsedTransactions;
    }

    for (let i = 0; i < txs.length; i++) {
      try {
        const txBytes = fromBase64(txs[i]);
        const txRaw = decodeTxRaw(txBytes);
        
        // Get transaction result from block results  
        const txResults = (blockResults as any).results || [];
        const txResult = txResults[i];
        const success = txResult?.code === 0;
        const events = txResult?.events || [];
        
        // Parse messages from the transaction
        const messages = this.parseMessages(txRaw.body.messages);
        
        const parsedTx: ParsedTransaction = {
          hash: this.getTxHash(txs[i]),
          success,
          messages,
          events
        };

        parsedTransactions.push(parsedTx);

        if (success && this.hasSedaMessages(messages)) {
          logger.debug("Found SEDA transaction");
        }
      } catch (error) {
        logger.warn("Failed to parse transaction");
      }
    }

    return parsedTransactions;
  }

  parseMessages(messages: any[]): ParsedMessage[] {
    const parsedMessages: ParsedMessage[] = [];

    for (const message of messages) {
      try {
        const parsedMessage: ParsedMessage = {
          typeUrl: message.typeUrl || '',
          value: message.value,
          sedaContext: this.extractSedaContext(message)
        };

        parsedMessages.push(parsedMessage);
      } catch (error) {
        logger.warn("Failed to parse message");
      }
    }

    return parsedMessages;
  }

  private extractSedaContext(message: any): SedaMessageContext | undefined {
    if (!message.typeUrl) return undefined;

    // Check for SEDA-specific message types
    if (message.typeUrl.includes('post_data_request')) {
      return {
        type: 'post_data_request'
        // DR ID will be generated by DataRequestIdGenerator
      };
    }

    if (message.typeUrl.includes('commit_data_result')) {
      return {
        type: 'commit_data_result',
        // Extract commitment hash and public key from message value if available
        commitmentHash: message.value?.commitment,
        publicKey: message.value?.public_key
      };
    }

    if (message.typeUrl.includes('reveal_data_result')) {
      return {
        type: 'reveal_data_result',
        // Extract public key from message value if available
        publicKey: message.value?.public_key
      };
    }

    return undefined;
  }

  private hasSedaMessages(messages: ParsedMessage[]): boolean {
    return messages.some(msg => msg.sedaContext !== undefined);
  }

  private getTxHash(txBase64: string): string {
    // For now, use a simple hash of the base64 string
    // In a real implementation, this would be the actual transaction hash
    const hash = Array.from(fromBase64(txBase64))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('')
      .substring(0, 64);
    
    return hash;
  }

  extractDataRequestId(message: ParsedMessage): string | null {
    // This will be integrated with DataRequestIdGenerator in Phase 6
    // For now, return null to indicate DR ID needs to be generated
    if (message.sedaContext?.type === 'post_data_request') {
      return null; // Will be generated by DataRequestIdGenerator
    }

    // For commit/reveal messages, try to extract DR ID from message or events
    if (message.sedaContext?.type === 'commit_data_result' || 
        message.sedaContext?.type === 'reveal_data_result') {
      // This would need to be extracted from the message value or related events
      return message.value?.data_request_id || null;
    }

    return null;
  }

  isSuccessfulTransaction(txResult: any): boolean {
    return txResult?.code === 0;
  }

  // Enhanced block parsing that populates transactions in BlockEvent
  enhanceBlockEvent(blockEvent: BlockEvent): BlockEvent {
    const transactions = this.parseBlock(blockEvent.block, blockEvent.blockResults);
    
    return {
      ...blockEvent,
      transactions
    };
  }
} 