{
	"contract_name": "seda-contract",
	"contract_version": "1.0.1",
	"idl_version": "1.0.0",
	"instantiate": {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"title": "InstantiateMsg",
		"type": "object",
		"required": ["chain_id", "owner", "token"],
		"properties": {
			"chain_id": {
				"type": "string"
			},
			"owner": {
				"type": "string"
			},
			"staking_config": {
				"anyOf": [
					{
						"$ref": "#/definitions/StakingConfig"
					},
					{
						"type": "null"
					}
				]
			},
			"timeout_config": {
				"anyOf": [
					{
						"$ref": "#/definitions/TimeoutConfig"
					},
					{
						"type": "null"
					}
				]
			},
			"token": {
				"type": "string"
			}
		},
		"additionalProperties": false,
		"definitions": {
			"StakingConfig": {
				"description": "Governance-controlled staking configuration parameters",
				"type": "object",
				"required": ["allowlist_enabled", "minimum_stake"],
				"properties": {
					"allowlist_enabled": {
						"description": "Whether the allowlist is enabled",
						"type": "boolean"
					},
					"minimum_stake": {
						"description": "Minimum amount of SEDA tokens required to register as a data request executor",
						"allOf": [
							{
								"$ref": "#/definitions/Uint128"
							}
						]
					}
				},
				"additionalProperties": false
			},
			"TimeoutConfig": {
				"description": "Governance-controlled timeout configuration parameters",
				"type": "object",
				"required": ["commit_timeout_in_blocks", "reveal_timeout_in_blocks"],
				"properties": {
					"commit_timeout_in_blocks": {
						"description": "Number of blocks after which a data request is timed out while waiting for commits.",
						"type": "integer",
						"format": "uint64",
						"minimum": 0.0
					},
					"reveal_timeout_in_blocks": {
						"description": "Number of blocks after which a data request is timed out while waiting for reveals.",
						"type": "integer",
						"format": "uint64",
						"minimum": 0.0
					}
				},
				"additionalProperties": false
			},
			"Uint128": {
				"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
				"type": "string"
			}
		}
	},
	"execute": {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"title": "ExecuteMsg",
		"anyOf": [
			{
				"$ref": "#/definitions/ExecuteMsg"
			},
			{
				"$ref": "#/definitions/ExecuteMsg2"
			},
			{
				"$ref": "#/definitions/ExecuteMsg3"
			}
		],
		"definitions": {
			"Binary": {
				"description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
				"type": "string"
			},
			"Execute": {
				"type": "object",
				"required": ["commitment", "dr_id", "proof", "public_key"],
				"properties": {
					"commitment": {
						"type": "string"
					},
					"dr_id": {
						"type": "string"
					},
					"proof": {
						"type": "string"
					},
					"public_key": {
						"description": "A hash of the reveal message, not just the reveal body",
						"type": "string"
					}
				},
				"additionalProperties": false
			},
			"Execute10": {
				"type": "object",
				"required": ["public_key"],
				"properties": {
					"public_key": {
						"description": "The public key of the person.",
						"type": "string"
					}
				},
				"additionalProperties": false
			},
			"Execute11": {
				"type": "object",
				"additionalProperties": false
			},
			"Execute12": {
				"type": "object",
				"additionalProperties": false
			},
			"Execute2": {
				"type": "object",
				"required": ["payback_address", "posted_dr", "seda_payload"],
				"properties": {
					"payback_address": {
						"$ref": "#/definitions/Binary"
					},
					"posted_dr": {
						"$ref": "#/definitions/PostDataRequestArgs"
					},
					"seda_payload": {
						"$ref": "#/definitions/Binary"
					}
				},
				"additionalProperties": false
			},
			"Execute3": {
				"type": "object",
				"required": ["proof", "public_key", "reveal_body", "stderr", "stdout"],
				"properties": {
					"proof": {
						"type": "string"
					},
					"public_key": {
						"type": "string"
					},
					"reveal_body": {
						"$ref": "#/definitions/RevealBody"
					},
					"stderr": {
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"stdout": {
						"type": "array",
						"items": {
							"type": "string"
						}
					}
				},
				"additionalProperties": false
			},
			"Execute4": {
				"type": "object",
				"required": ["proof", "public_key"],
				"properties": {
					"memo": {
						"anyOf": [
							{
								"$ref": "#/definitions/Binary"
							},
							{
								"type": "null"
							}
						]
					},
					"proof": {
						"type": "string"
					},
					"public_key": {
						"type": "string"
					}
				},
				"additionalProperties": false
			},
			"Execute5": {
				"type": "object",
				"required": ["proof", "public_key"],
				"properties": {
					"proof": {
						"type": "string"
					},
					"public_key": {
						"type": "string"
					}
				},
				"additionalProperties": false
			},
			"Execute6": {
				"type": "object",
				"required": ["proof", "public_key", "withdraw_address"],
				"properties": {
					"proof": {
						"type": "string"
					},
					"public_key": {
						"type": "string"
					},
					"withdraw_address": {
						"type": "string"
					}
				},
				"additionalProperties": false
			},
			"Execute7": {
				"type": "object",
				"required": ["new_owner"],
				"properties": {
					"new_owner": {
						"type": "string"
					}
				},
				"additionalProperties": false
			},
			"Execute8": {
				"type": "object",
				"additionalProperties": false
			},
			"Execute9": {
				"type": "object",
				"required": ["public_key"],
				"properties": {
					"public_key": {
						"description": "The public key of the person.",
						"type": "string"
					}
				},
				"additionalProperties": false
			},
			"ExecuteMsg": {
				"oneOf": [
					{
						"type": "object",
						"required": ["commit_data_result"],
						"properties": {
							"commit_data_result": {
								"$ref": "#/definitions/Execute"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["post_data_request"],
						"properties": {
							"post_data_request": {
								"$ref": "#/definitions/Execute2"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["reveal_data_result"],
						"properties": {
							"reveal_data_result": {
								"$ref": "#/definitions/Execute3"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["set_timeout_config"],
						"properties": {
							"set_timeout_config": {
								"$ref": "#/definitions/TimeoutConfig"
							}
						},
						"additionalProperties": false
					}
				]
			},
			"ExecuteMsg2": {
				"oneOf": [
					{
						"type": "object",
						"required": ["stake"],
						"properties": {
							"stake": {
								"$ref": "#/definitions/Execute4"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["unstake"],
						"properties": {
							"unstake": {
								"$ref": "#/definitions/Execute5"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["withdraw"],
						"properties": {
							"withdraw": {
								"$ref": "#/definitions/Execute6"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["set_staking_config"],
						"properties": {
							"set_staking_config": {
								"$ref": "#/definitions/StakingConfig"
							}
						},
						"additionalProperties": false
					}
				]
			},
			"ExecuteMsg3": {
				"oneOf": [
					{
						"type": "object",
						"required": ["transfer_ownership"],
						"properties": {
							"transfer_ownership": {
								"$ref": "#/definitions/Execute7"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["accept_ownership"],
						"properties": {
							"accept_ownership": {
								"$ref": "#/definitions/Execute8"
							}
						},
						"additionalProperties": false
					},
					{
						"description": "Add a user to the allowlist.",
						"type": "object",
						"required": ["add_to_allowlist"],
						"properties": {
							"add_to_allowlist": {
								"$ref": "#/definitions/Execute9"
							}
						},
						"additionalProperties": false
					},
					{
						"description": "Remove a user from the allowlist.",
						"type": "object",
						"required": ["remove_from_allowlist"],
						"properties": {
							"remove_from_allowlist": {
								"$ref": "#/definitions/Execute10"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["pause"],
						"properties": {
							"pause": {
								"$ref": "#/definitions/Execute11"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["unpause"],
						"properties": {
							"unpause": {
								"$ref": "#/definitions/Execute12"
							}
						},
						"additionalProperties": false
					}
				]
			},
			"PostDataRequestArgs": {
				"type": "object",
				"required": [
					"consensus_filter",
					"exec_gas_limit",
					"exec_inputs",
					"exec_program_id",
					"gas_price",
					"memo",
					"replication_factor",
					"tally_gas_limit",
					"tally_inputs",
					"tally_program_id",
					"version"
				],
				"properties": {
					"consensus_filter": {
						"$ref": "#/definitions/Binary"
					},
					"exec_gas_limit": {
						"type": "integer",
						"format": "uint64",
						"minimum": 0.0
					},
					"exec_inputs": {
						"$ref": "#/definitions/Binary"
					},
					"exec_program_id": {
						"type": "string"
					},
					"gas_price": {
						"$ref": "#/definitions/Uint128"
					},
					"memo": {
						"$ref": "#/definitions/Binary"
					},
					"replication_factor": {
						"type": "integer",
						"format": "uint16",
						"minimum": 0.0
					},
					"tally_gas_limit": {
						"type": "integer",
						"format": "uint64",
						"minimum": 0.0
					},
					"tally_inputs": {
						"$ref": "#/definitions/Binary"
					},
					"tally_program_id": {
						"type": "string"
					},
					"version": {
						"type": "string",
						"pattern": "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
					}
				},
				"additionalProperties": false
			},
			"RevealBody": {
				"description": "A revealed data request result that is hashed and signed by the executor",
				"type": "object",
				"required": ["dr_block_height", "dr_id", "exit_code", "gas_used", "proxy_public_keys", "reveal"],
				"properties": {
					"dr_block_height": {
						"type": "integer",
						"format": "uint64",
						"minimum": 0.0
					},
					"dr_id": {
						"type": "string"
					},
					"exit_code": {
						"type": "integer",
						"format": "uint8",
						"minimum": 0.0
					},
					"gas_used": {
						"type": "integer",
						"format": "uint64",
						"minimum": 0.0
					},
					"proxy_public_keys": {
						"type": "array",
						"items": {
							"type": "string"
						}
					},
					"reveal": {
						"$ref": "#/definitions/Binary"
					}
				},
				"additionalProperties": false
			},
			"StakingConfig": {
				"description": "Governance-controlled staking configuration parameters",
				"type": "object",
				"required": ["allowlist_enabled", "minimum_stake"],
				"properties": {
					"allowlist_enabled": {
						"description": "Whether the allowlist is enabled",
						"type": "boolean"
					},
					"minimum_stake": {
						"description": "Minimum amount of SEDA tokens required to register as a data request executor",
						"allOf": [
							{
								"$ref": "#/definitions/Uint128"
							}
						]
					}
				},
				"additionalProperties": false
			},
			"TimeoutConfig": {
				"description": "Governance-controlled timeout configuration parameters",
				"type": "object",
				"required": ["commit_timeout_in_blocks", "reveal_timeout_in_blocks"],
				"properties": {
					"commit_timeout_in_blocks": {
						"description": "Number of blocks after which a data request is timed out while waiting for commits.",
						"type": "integer",
						"format": "uint64",
						"minimum": 0.0
					},
					"reveal_timeout_in_blocks": {
						"description": "Number of blocks after which a data request is timed out while waiting for reveals.",
						"type": "integer",
						"format": "uint64",
						"minimum": 0.0
					}
				},
				"additionalProperties": false
			},
			"Uint128": {
				"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
				"type": "string"
			}
		}
	},
	"query": {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"title": "QueryMsg",
		"anyOf": [
			{
				"$ref": "#/definitions/QueryMsg"
			},
			{
				"$ref": "#/definitions/QueryMsg2"
			},
			{
				"$ref": "#/definitions/QueryMsg3"
			}
		],
		"definitions": {
			"Binary": {
				"description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
				"type": "string"
			},
			"DataRequestStatus": {
				"type": "string",
				"enum": ["committing", "revealing", "tallying"]
			},
			"Query": {
				"type": "object",
				"required": ["data"],
				"properties": {
					"data": {
						"$ref": "#/definitions/Binary"
					}
				},
				"additionalProperties": false
			},
			"QueryMsg": {
				"oneOf": [
					{
						"type": "object",
						"required": ["can_executor_commit"],
						"properties": {
							"can_executor_commit": {
								"type": "object",
								"required": ["commitment", "dr_id", "proof", "public_key"],
								"properties": {
									"commitment": {
										"type": "string"
									},
									"dr_id": {
										"type": "string"
									},
									"proof": {
										"type": "string"
									},
									"public_key": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["can_executor_reveal"],
						"properties": {
							"can_executor_reveal": {
								"type": "object",
								"required": ["dr_id", "public_key"],
								"properties": {
									"dr_id": {
										"type": "string"
									},
									"public_key": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_data_request"],
						"properties": {
							"get_data_request": {
								"type": "object",
								"required": ["dr_id"],
								"properties": {
									"dr_id": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_data_request_commitment"],
						"properties": {
							"get_data_request_commitment": {
								"type": "object",
								"required": ["dr_id", "public_key"],
								"properties": {
									"dr_id": {
										"type": "string"
									},
									"public_key": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_data_request_commitments"],
						"properties": {
							"get_data_request_commitments": {
								"type": "object",
								"required": ["dr_id"],
								"properties": {
									"dr_id": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_data_request_reveal"],
						"properties": {
							"get_data_request_reveal": {
								"type": "object",
								"required": ["dr_id", "public_key"],
								"properties": {
									"dr_id": {
										"type": "string"
									},
									"public_key": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_data_request_reveals"],
						"properties": {
							"get_data_request_reveals": {
								"type": "object",
								"required": ["dr_id"],
								"properties": {
									"dr_id": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_data_requests_by_status"],
						"properties": {
							"get_data_requests_by_status": {
								"type": "object",
								"required": ["limit", "status"],
								"properties": {
									"last_seen_index": {
										"type": ["array", "null"],
										"items": [
											{
												"$ref": "#/definitions/Uint128"
											},
											{
												"type": "integer",
												"format": "uint64",
												"minimum": 0.0
											},
											{
												"type": "array",
												"items": {
													"type": "integer",
													"format": "uint8",
													"minimum": 0.0
												},
												"maxItems": 32,
												"minItems": 32
											}
										],
										"maxItems": 3,
										"minItems": 3
									},
									"limit": {
										"type": "integer",
										"format": "uint32",
										"minimum": 0.0
									},
									"status": {
										"$ref": "#/definitions/DataRequestStatus"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					}
				]
			},
			"QueryMsg2": {
				"oneOf": [
					{
						"type": "object",
						"required": ["get_staker"],
						"properties": {
							"get_staker": {
								"type": "object",
								"required": ["public_key"],
								"properties": {
									"public_key": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_account_seq"],
						"properties": {
							"get_account_seq": {
								"type": "object",
								"required": ["public_key"],
								"properties": {
									"public_key": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_staker_and_seq"],
						"properties": {
							"get_staker_and_seq": {
								"type": "object",
								"required": ["public_key"],
								"properties": {
									"public_key": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["is_staker_executor"],
						"properties": {
							"is_staker_executor": {
								"type": "object",
								"required": ["public_key"],
								"properties": {
									"public_key": {
										"type": "string"
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["is_executor_eligible"],
						"properties": {
							"is_executor_eligible": {
								"$ref": "#/definitions/Query"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_staking_config"],
						"properties": {
							"get_staking_config": {
								"type": "object",
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_executors"],
						"properties": {
							"get_executors": {
								"type": "object",
								"required": ["limit", "offset"],
								"properties": {
									"limit": {
										"type": "integer",
										"format": "uint32",
										"minimum": 0.0
									},
									"offset": {
										"type": "integer",
										"format": "uint32",
										"minimum": 0.0
									}
								},
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					}
				]
			},
			"QueryMsg3": {
				"oneOf": [
					{
						"type": "object",
						"required": ["get_owner"],
						"properties": {
							"get_owner": {
								"type": "object",
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["get_pending_owner"],
						"properties": {
							"get_pending_owner": {
								"type": "object",
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["is_paused"],
						"properties": {
							"is_paused": {
								"type": "object",
								"additionalProperties": false
							}
						},
						"additionalProperties": false
					}
				]
			},
			"Uint128": {
				"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
				"type": "string"
			}
		}
	},
	"migrate": null,
	"sudo": {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"title": "SudoMsg",
		"anyOf": [
			{
				"$ref": "#/definitions/SudoMsg"
			}
		],
		"definitions": {
			"DistributionBurn": {
				"type": "object",
				"required": ["amount"],
				"properties": {
					"amount": {
						"description": "The amount to burn",
						"allOf": [
							{
								"$ref": "#/definitions/Uint128"
							}
						]
					}
				},
				"additionalProperties": false
			},
			"DistributionDataProxyReward": {
				"type": "object",
				"required": ["amount", "payout_address", "public_key"],
				"properties": {
					"amount": {
						"description": "The amount to send to the address.",
						"allOf": [
							{
								"$ref": "#/definitions/Uint128"
							}
						]
					},
					"payout_address": {
						"description": "The address to send the funds to.",
						"type": "string"
					},
					"public_key": {
						"description": "The public key of the data proxy as a hex string.",
						"type": "string"
					}
				},
				"additionalProperties": false
			},
			"DistributionExecutorReward": {
				"type": "object",
				"required": ["amount", "identity"],
				"properties": {
					"amount": {
						"description": "The amount to burn",
						"allOf": [
							{
								"$ref": "#/definitions/Uint128"
							}
						]
					},
					"identity": {
						"description": "The identity to reward.",
						"type": "string"
					}
				},
				"additionalProperties": false
			},
			"DistributionMessage": {
				"oneOf": [
					{
						"description": "For burning funds",
						"type": "object",
						"required": ["burn"],
						"properties": {
							"burn": {
								"$ref": "#/definitions/DistributionBurn"
							}
						},
						"additionalProperties": false
					},
					{
						"description": "For rewarding an executor",
						"type": "object",
						"required": ["executor_reward"],
						"properties": {
							"executor_reward": {
								"$ref": "#/definitions/DistributionExecutorReward"
							}
						},
						"additionalProperties": false
					},
					{
						"description": "For rewarding a data proxy",
						"type": "object",
						"required": ["data_proxy_reward"],
						"properties": {
							"data_proxy_reward": {
								"$ref": "#/definitions/DistributionDataProxyReward"
							}
						},
						"additionalProperties": false
					}
				]
			},
			"Sudo": {
				"type": "object",
				"required": ["requests"],
				"properties": {
					"requests": {
						"type": "object",
						"additionalProperties": false
					}
				},
				"additionalProperties": false
			},
			"Sudo2": {
				"type": "object",
				"additionalProperties": false
			},
			"SudoMsg": {
				"oneOf": [
					{
						"type": "object",
						"required": ["remove_data_requests"],
						"properties": {
							"remove_data_requests": {
								"$ref": "#/definitions/Sudo"
							}
						},
						"additionalProperties": false
					},
					{
						"type": "object",
						"required": ["expire_data_requests"],
						"properties": {
							"expire_data_requests": {
								"$ref": "#/definitions/Sudo2"
							}
						},
						"additionalProperties": false
					}
				]
			},
			"Uint128": {
				"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
				"type": "string"
			}
		}
	},
	"responses": {
		"can_executor_commit": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Boolean",
			"type": "boolean"
		},
		"can_executor_reveal": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Boolean",
			"type": "boolean"
		},
		"get_account_seq": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Uint128",
			"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
			"type": "string"
		},
		"get_data_request": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Nullable_DataRequest",
			"anyOf": [
				{
					"$ref": "#/definitions/DataRequest"
				},
				{
					"type": "null"
				}
			],
			"definitions": {
				"Binary": {
					"description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
					"type": "string"
				},
				"DataRequest": {
					"description": "Represents a data request at creation time",
					"type": "object",
					"required": [
						"commits",
						"consensus_filter",
						"exec_gas_limit",
						"exec_inputs",
						"exec_program_id",
						"gas_price",
						"height",
						"id",
						"memo",
						"payback_address",
						"replication_factor",
						"reveals",
						"seda_payload",
						"tally_gas_limit",
						"tally_inputs",
						"tally_program_id",
						"version"
					],
					"properties": {
						"commits": {
							"description": "Commitments submitted by executors",
							"type": "object",
							"additionalProperties": false
						},
						"consensus_filter": {
							"description": "Filter applied before tally execution",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"exec_gas_limit": {
							"description": "The limit to how much gas should be used for executing the DR",
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"exec_inputs": {
							"description": "Inputs for DR WASM binary",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"exec_program_id": {
							"description": "Identifier of DR WASM binary",
							"type": "string"
						},
						"gas_price": {
							"description": "Amount of SEDA tokens per gas unit",
							"allOf": [
								{
									"$ref": "#/definitions/Uint128"
								}
							]
						},
						"height": {
							"description": "The height data request was posted. Used for commitment.",
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"id": {
							"description": "Identifier",
							"type": "string"
						},
						"memo": {
							"description": "Public info attached to DR",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"payback_address": {
							"description": "Payback address set by the relayer",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"replication_factor": {
							"description": "Amount of required DR executors",
							"type": "integer",
							"format": "uint16",
							"minimum": 0.0
						},
						"reveals": {
							"description": "Reveals submitted by executors",
							"type": "object",
							"additionalProperties": false
						},
						"seda_payload": {
							"description": "Payload set by SEDA Protocol (e.g. OEV-enabled data requests)",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"tally_gas_limit": {
							"description": "The limit to how much gas should be used for tallying the DR",
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"tally_inputs": {
							"description": "Inputs for Tally WASM binary",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"tally_program_id": {
							"description": "Identifier of Tally WASM binary",
							"type": "string"
						},
						"version": {
							"description": "Semantic Version String",
							"type": "string",
							"pattern": "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
						}
					},
					"additionalProperties": false
				},
				"RevealBody": {
					"description": "A revealed data request result that is hashed and signed by the executor",
					"type": "object",
					"required": ["dr_block_height", "dr_id", "exit_code", "gas_used", "proxy_public_keys", "reveal"],
					"properties": {
						"dr_block_height": {
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"dr_id": {
							"type": "string"
						},
						"exit_code": {
							"type": "integer",
							"format": "uint8",
							"minimum": 0.0
						},
						"gas_used": {
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"proxy_public_keys": {
							"type": "array",
							"items": {
								"type": "string"
							}
						},
						"reveal": {
							"$ref": "#/definitions/Binary"
						}
					},
					"additionalProperties": false
				},
				"Uint128": {
					"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
					"type": "string"
				}
			}
		},
		"get_data_request_commitment": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Nullable_String",
			"type": ["string", "null"]
		},
		"get_data_request_commitments": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Map_of_String",
			"type": "object",
			"additionalProperties": false
		},
		"get_data_request_reveal": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Nullable_RevealBody",
			"anyOf": [
				{
					"$ref": "#/definitions/RevealBody"
				},
				{
					"type": "null"
				}
			],
			"definitions": {
				"Binary": {
					"description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
					"type": "string"
				},
				"RevealBody": {
					"description": "A revealed data request result that is hashed and signed by the executor",
					"type": "object",
					"required": ["dr_block_height", "dr_id", "exit_code", "gas_used", "proxy_public_keys", "reveal"],
					"properties": {
						"dr_block_height": {
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"dr_id": {
							"type": "string"
						},
						"exit_code": {
							"type": "integer",
							"format": "uint8",
							"minimum": 0.0
						},
						"gas_used": {
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"proxy_public_keys": {
							"type": "array",
							"items": {
								"type": "string"
							}
						},
						"reveal": {
							"$ref": "#/definitions/Binary"
						}
					},
					"additionalProperties": false
				}
			}
		},
		"get_data_request_reveals": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Map_of_RevealBody",
			"type": "object",
			"additionalProperties": false,
			"definitions": {
				"Binary": {
					"description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
					"type": "string"
				},
				"RevealBody": {
					"description": "A revealed data request result that is hashed and signed by the executor",
					"type": "object",
					"required": ["dr_block_height", "dr_id", "exit_code", "gas_used", "proxy_public_keys", "reveal"],
					"properties": {
						"dr_block_height": {
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"dr_id": {
							"type": "string"
						},
						"exit_code": {
							"type": "integer",
							"format": "uint8",
							"minimum": 0.0
						},
						"gas_used": {
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"proxy_public_keys": {
							"type": "array",
							"items": {
								"type": "string"
							}
						},
						"reveal": {
							"$ref": "#/definitions/Binary"
						}
					},
					"additionalProperties": false
				}
			}
		},
		"get_data_requests_by_status": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "GetDataRequestsByStatusResponse",
			"type": "object",
			"required": ["data_requests", "is_paused", "total"],
			"properties": {
				"data_requests": {
					"type": "array",
					"items": {
						"$ref": "#/definitions/DataRequest"
					}
				},
				"is_paused": {
					"type": "boolean"
				},
				"last_seen_index": {
					"type": ["array", "null"],
					"items": [
						{
							"$ref": "#/definitions/Uint128"
						},
						{
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						{
							"type": "array",
							"items": {
								"type": "integer",
								"format": "uint8",
								"minimum": 0.0
							},
							"maxItems": 32,
							"minItems": 32
						}
					],
					"maxItems": 3,
					"minItems": 3
				},
				"total": {
					"type": "integer",
					"format": "uint32",
					"minimum": 0.0
				}
			},
			"additionalProperties": false,
			"definitions": {
				"Binary": {
					"description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
					"type": "string"
				},
				"DataRequest": {
					"description": "Represents a data request at creation time",
					"type": "object",
					"required": [
						"commits",
						"consensus_filter",
						"exec_gas_limit",
						"exec_inputs",
						"exec_program_id",
						"gas_price",
						"height",
						"id",
						"memo",
						"payback_address",
						"replication_factor",
						"reveals",
						"seda_payload",
						"tally_gas_limit",
						"tally_inputs",
						"tally_program_id",
						"version"
					],
					"properties": {
						"commits": {
							"description": "Commitments submitted by executors",
							"type": "object",
							"additionalProperties": false
						},
						"consensus_filter": {
							"description": "Filter applied before tally execution",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"exec_gas_limit": {
							"description": "The limit to how much gas should be used for executing the DR",
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"exec_inputs": {
							"description": "Inputs for DR WASM binary",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"exec_program_id": {
							"description": "Identifier of DR WASM binary",
							"type": "string"
						},
						"gas_price": {
							"description": "Amount of SEDA tokens per gas unit",
							"allOf": [
								{
									"$ref": "#/definitions/Uint128"
								}
							]
						},
						"height": {
							"description": "The height data request was posted. Used for commitment.",
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"id": {
							"description": "Identifier",
							"type": "string"
						},
						"memo": {
							"description": "Public info attached to DR",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"payback_address": {
							"description": "Payback address set by the relayer",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"replication_factor": {
							"description": "Amount of required DR executors",
							"type": "integer",
							"format": "uint16",
							"minimum": 0.0
						},
						"reveals": {
							"description": "Reveals submitted by executors",
							"type": "object",
							"additionalProperties": false
						},
						"seda_payload": {
							"description": "Payload set by SEDA Protocol (e.g. OEV-enabled data requests)",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"tally_gas_limit": {
							"description": "The limit to how much gas should be used for tallying the DR",
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"tally_inputs": {
							"description": "Inputs for Tally WASM binary",
							"allOf": [
								{
									"$ref": "#/definitions/Binary"
								}
							]
						},
						"tally_program_id": {
							"description": "Identifier of Tally WASM binary",
							"type": "string"
						},
						"version": {
							"description": "Semantic Version String",
							"type": "string",
							"pattern": "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
						}
					},
					"additionalProperties": false
				},
				"RevealBody": {
					"description": "A revealed data request result that is hashed and signed by the executor",
					"type": "object",
					"required": ["dr_block_height", "dr_id", "exit_code", "gas_used", "proxy_public_keys", "reveal"],
					"properties": {
						"dr_block_height": {
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"dr_id": {
							"type": "string"
						},
						"exit_code": {
							"type": "integer",
							"format": "uint8",
							"minimum": 0.0
						},
						"gas_used": {
							"type": "integer",
							"format": "uint64",
							"minimum": 0.0
						},
						"proxy_public_keys": {
							"type": "array",
							"items": {
								"type": "string"
							}
						},
						"reveal": {
							"$ref": "#/definitions/Binary"
						}
					},
					"additionalProperties": false
				},
				"Uint128": {
					"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
					"type": "string"
				}
			}
		},
		"get_executors": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "GetExecutorsResponse",
			"type": "object",
			"required": ["executors"],
			"properties": {
				"executors": {
					"type": "array",
					"items": {
						"$ref": "#/definitions/Executor"
					}
				}
			},
			"additionalProperties": false,
			"definitions": {
				"Binary": {
					"description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
					"type": "string"
				},
				"Executor": {
					"type": "object",
					"required": ["public_key", "tokens_pending_withdrawal", "tokens_staked"],
					"properties": {
						"memo": {
							"anyOf": [
								{
									"$ref": "#/definitions/Binary"
								},
								{
									"type": "null"
								}
							]
						},
						"public_key": {
							"type": "string"
						},
						"tokens_pending_withdrawal": {
							"$ref": "#/definitions/Uint128"
						},
						"tokens_staked": {
							"$ref": "#/definitions/Uint128"
						}
					},
					"additionalProperties": false
				},
				"Uint128": {
					"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
					"type": "string"
				}
			}
		},
		"get_owner": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Addr",
			"description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
			"type": "string"
		},
		"get_pending_owner": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Nullable_Addr",
			"anyOf": [
				{
					"$ref": "#/definitions/Addr"
				},
				{
					"type": "null"
				}
			],
			"definitions": {
				"Addr": {
					"description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
					"type": "string"
				}
			}
		},
		"get_staker": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Nullable_Staker",
			"anyOf": [
				{
					"$ref": "#/definitions/Staker"
				},
				{
					"type": "null"
				}
			],
			"definitions": {
				"Binary": {
					"description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
					"type": "string"
				},
				"Staker": {
					"description": "A data request executor with staking info and optional p2p multi address",
					"type": "object",
					"required": ["tokens_pending_withdrawal", "tokens_staked"],
					"properties": {
						"memo": {
							"anyOf": [
								{
									"$ref": "#/definitions/Binary"
								},
								{
									"type": "null"
								}
							]
						},
						"tokens_pending_withdrawal": {
							"$ref": "#/definitions/Uint128"
						},
						"tokens_staked": {
							"$ref": "#/definitions/Uint128"
						}
					},
					"additionalProperties": false
				},
				"Uint128": {
					"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
					"type": "string"
				}
			}
		},
		"get_staker_and_seq": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "StakerAndSeq",
			"type": "object",
			"required": ["seq"],
			"properties": {
				"seq": {
					"$ref": "#/definitions/Uint128"
				},
				"staker": {
					"anyOf": [
						{
							"$ref": "#/definitions/Staker"
						},
						{
							"type": "null"
						}
					]
				}
			},
			"additionalProperties": false,
			"definitions": {
				"Binary": {
					"description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
					"type": "string"
				},
				"Staker": {
					"description": "A data request executor with staking info and optional p2p multi address",
					"type": "object",
					"required": ["tokens_pending_withdrawal", "tokens_staked"],
					"properties": {
						"memo": {
							"anyOf": [
								{
									"$ref": "#/definitions/Binary"
								},
								{
									"type": "null"
								}
							]
						},
						"tokens_pending_withdrawal": {
							"$ref": "#/definitions/Uint128"
						},
						"tokens_staked": {
							"$ref": "#/definitions/Uint128"
						}
					},
					"additionalProperties": false
				},
				"Uint128": {
					"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
					"type": "string"
				}
			}
		},
		"get_staking_config": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "StakingConfig",
			"description": "Governance-controlled staking configuration parameters",
			"type": "object",
			"required": ["allowlist_enabled", "minimum_stake"],
			"properties": {
				"allowlist_enabled": {
					"description": "Whether the allowlist is enabled",
					"type": "boolean"
				},
				"minimum_stake": {
					"description": "Minimum amount of SEDA tokens required to register as a data request executor",
					"allOf": [
						{
							"$ref": "#/definitions/Uint128"
						}
					]
				}
			},
			"additionalProperties": false,
			"definitions": {
				"Uint128": {
					"description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
					"type": "string"
				}
			}
		},
		"is_executor_eligible": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Boolean",
			"type": "boolean"
		},
		"is_paused": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Boolean",
			"type": "boolean"
		},
		"is_staker_executor": {
			"$schema": "http://json-schema.org/draft-07/schema#",
			"title": "Boolean",
			"type": "boolean"
		}
	}
}
